pragma solidity >=0.6.7;

import "ds-test/test.sol";
import "ds-token/token.sol";
import "ds-thing/thing.sol";

import "./VoteQuorum.sol";

contract VoteQuorumUser {
    VoteQuorum voteQuorum;

    constructor(VoteQuorum voteQuorum_) public { voteQuorum = voteQuorum_; }
    function approve(DSToken token, address recipient, uint amount) public returns (bool)  {
        return token.approve(recipient, amount);
    }

    function etch(address[] memory guys) public returns (bytes32) { return voteQuorum.etch(guys); }
    function vote(address[] memory guys) public returns (bytes32) { return voteQuorum.vote(guys); }
    function vote(bytes32 id) public { voteQuorum.vote(id); }
    function lift(address candidate) public { voteQuorum.lift(candidate); }
    function lock(uint amt) public { voteQuorum.lock(amt); }
    function free(uint amt) public { voteQuorum.free(amt); }

    function tryFree(uint amt) public returns (bool ok) {
        string memory sig = "free(uint256)";
        (ok,) = address(voteQuorum).call(abi.encodeWithSignature(sig, amt));
    }
}

contract VoteQuorumTest is DSThing, DSTest {
    address constant candidateA = address(0x1);
    address constant candidateB = address(0x2);
    address constant candidateC = address(0x3);

    VoteQuorum voteQuorum;
    DSToken gov;
    DSToken iou;

    VoteQuorumUser innocentVoterA;
    VoteQuorumUser innocentVoterB;
    VoteQuorumUser altruist;
    VoteQuorumUser attackerA;
    VoteQuorumUser attackerB;

    function setUp() public {
        gov = new DSToken("GOV");

        VoteQuorumFactory fab = new VoteQuorumFactory();
        voteQuorum = fab.newVoteQuorum(gov, 3);
        iou = voteQuorum.IOU();

        innocentVoterA = new VoteQuorumUser(voteQuorum);
        innocentVoterB = new VoteQuorumUser(voteQuorum);

        altruist = new VoteQuorumUser(voteQuorum);

        attackerA = new VoteQuorumUser(voteQuorum);
        attackerB = new VoteQuorumUser(voteQuorum);

        gov.mint(address(innocentVoterA), 50 ether);
        gov.mint(address(innocentVoterB), 50 ether);
        gov.mint(address(altruist), 50 ether);
        gov.mint(address(attackerA), 50 ether);
        gov.mint(address(attackerB), 50 ether);
    }

    function approveAll() public {
        innocentVoterA.approve(gov, address(voteQuorum), 50 ether);
        innocentVoterB.approve(gov, address(voteQuorum), 50 ether);
        altruist.approve(gov, address(voteQuorum), 50 ether);
        attackerA.approve(gov, address(voteQuorum), 50 ether);
        attackerB.approve(gov, address(voteQuorum), 50 ether);
        innocentVoterA.approve(iou, address(voteQuorum), 50 ether);
        innocentVoterB.approve(iou, address(voteQuorum), 50 ether);
        altruist.approve(iou, address(voteQuorum), 50 ether);
        attackerA.approve(iou, address(voteQuorum), 50 ether);
        attackerB.approve(iou, address(voteQuorum), 50 ether);
    }

    function test_token_balance_sanity_check() public {
        assertEq(gov.balanceOf(address(innocentVoterA)), 50 ether);
        assertEq(gov.balanceOf(address(innocentVoterB)), 50 ether);
        assertEq(gov.balanceOf(address(attackerA)), 50 ether);
    }

    // variants of the slate camping exploit

    function testFail_exploit_A() public {
        approveAll();
        innocentVoterA.lock(50 ether);
        innocentVoterB.lock(50 ether);
        attackerA.lock(50 ether);

        // everybody starts with 50 mkr
        assertEq(voteQuorum.deposits(address(innocentVoterA)), 50 ether);
        assertEq(voteQuorum.deposits(address(innocentVoterB)), 50 ether);
        assertEq(voteQuorum.deposits(address(attackerA)), 50 ether);

        // some person votes for cadidate A
        address[] memory candidatesA = new address[](1);
        candidatesA[0] = candidateA;
        innocentVoterA.vote(candidatesA);
        assertEq(voteQuorum.approvals(address(candidateA)), 50 ether);
        assertEq(voteQuorum.approvals(address(candidateB)), 0 ether);

        // some person votes for cadidate B
        address[] memory candidatesB = new address[](1);
        candidatesB[0] = candidateB;
        innocentVoterB.vote(candidatesB);
        assertEq(voteQuorum.approvals(address(candidateA)), 50 ether);
        assertEq(voteQuorum.approvals(address(candidateB)), 50 ether);

        // the attacker votes for an uneteched slate that contains both a and b
        address[] memory candidatesAB = new address[](2);
        candidatesAB[0] = candidateA;
        candidatesAB[1] = candidateB;
        bytes32 slate = keccak256(abi.encodePacked(candidatesAB));
        attackerA.vote(slate);
        // this does not add approvals to either candidate
        assertEq(voteQuorum.approvals(address(candidateA)), 50 ether);
        assertEq(voteQuorum.approvals(address(candidateB)), 50 ether);

        // the attacker can now etch the slate [a, b] and free their mkr
        attackerA.etch(candidatesAB);
        assertTrue(attackerA.tryFree(50 ether));
        assertEq(gov.balanceOf(address(attackerA)), 50 ether);
        // approvals have been removed from both proposals
        assertEq(voteQuorum.approvals(address(candidateA)), 0 ether);
        assertEq(voteQuorum.approvals(address(candidateB)), 0 ether);
        // neither innocent voter can free their mkr
        assertTrue(!innocentVoterA.tryFree(50 ether));
        assertTrue(!innocentVoterB.tryFree(50 ether));
    }

    // "single candidate slate camping"
    function testFail_exploit_B() public {
        approveAll();
        innocentVoterA.lock(50 ether);
        innocentVoterB.lock(50 ether);
        attackerA.lock(50 ether);

        // the attacker gets word of the address of the latest maker spell
        address[] memory candidatesA = new address[](1);
        candidatesA[0] = candidateA;
        bytes32 slate = keccak256(abi.encodePacked(candidatesA));
        // so they squat on the slate containing it
        // note: this only works if the slate containing just that candidate has not yet been etched
        attackerA.vote(slate);
        // this does not add approvals to candidate a
        assertEq(voteQuorum.approvals(address(candidateA)), 0 ether);

        // now somebody votes for candidate a
        // (this etches the slate [a])
        innocentVoterA.vote(candidatesA);
        // this adds 50 approvals to candidate a
        assertEq(voteQuorum.approvals(address(candidateA)), 50 ether);

        // the attacker can withdraw their mkr
        assertTrue(attackerA.tryFree(50 ether));
        assertEq(gov.balanceOf(address(attackerA)), 50 ether);
        // this removes 50 approvals from candidate a
        assertEq(voteQuorum.approvals(address(candidateA)), 0 ether);

        // the innocent voter can no longer free their mkr
        assertTrue(!innocentVoterA.tryFree(50 ether));
    }

    // as a last ditch effort, an attacker can _always_ remove approvals and perma-lock mkr if they are willing to spend mkr first.
    // this may be necessary if every slate combination of candidates with some approval amount has already been etched
    // and the attacker doesn't want to play the waiting game required for variant b
    function testFail_exploit_C() public {
        approveAll();
        innocentVoterA.lock(50 ether);
        innocentVoterB.lock(50 ether);

        // some voters are voting for candidates a and b
        address[] memory candidatesA = new address[](1);
        candidatesA[0] = candidateA;
        innocentVoterA.vote(candidatesA);
        address[] memory candidatesB = new address[](1);
        candidatesB[0] = candidateB;
        innocentVoterB.vote(candidatesB);
        assertEq(voteQuorum.approvals(address(candidateA)), 50 ether);
        assertEq(voteQuorum.approvals(address(candidateB)), 50 ether);

        // etch the last possible unique slate given the two candidates
        address[] memory candidatesAB = new address[](2);
        candidatesAB[0] = candidateA;
        candidatesAB[1] = candidateB;
        innocentVoterA.etch(candidatesAB);
        // the attacker can no longer perform a "variant a" style attack

        // however, the attacker can always find an unetched slate by adding an arbitrary address
        attackerA.lock(50 ether);
        address[] memory candidatesABC = new address[](3);
        candidatesABC[0] = candidateA;
        candidatesABC[1] = candidateB;
        candidatesABC[2] = candidateC;
        bytes32 slate = keccak256(abi.encodePacked(candidatesABC));
        attackerA.vote(slate);
        // this does not add approvals to any candidate
        assertEq(voteQuorum.approvals(address(candidateA)), 50 ether);
        assertEq(voteQuorum.approvals(address(candidateB)), 50 ether);
        assertEq(voteQuorum.approvals(address(candidateC)), 0 ether);

        // since candidate c has no approvals, the attacker can also not yet perform the attack
        attackerA.etch(candidatesABC);
        assertTrue(!attackerA.tryFree(50 ether));
        // but they can use a second address to add approvals to the new address
        attackerB.lock(50 ether);
        address[] memory candidatesC = new address[](1);
        candidatesC[0] = candidateC;
        attackerB.vote(candidatesC);
        assertEq(voteQuorum.approvals(address(candidateA)), 50 ether);
        assertEq(voteQuorum.approvals(address(candidateB)), 50 ether);
        assertEq(voteQuorum.approvals(address(candidateC)), 50 ether);

        // now the attacker may free mkr, removing approvals from all candidates
        assertTrue(attackerA.tryFree(50 ether));
        assertEq(voteQuorum.approvals(address(candidateA)), 0 ether);
        assertEq(voteQuorum.approvals(address(candidateB)), 0 ether);
        assertEq(voteQuorum.approvals(address(candidateC)), 0 ether);

        // nobody else can free their mkr
        assertTrue(!innocentVoterA.tryFree(50 ether));
        assertTrue(!innocentVoterB.tryFree(50 ether));
        assertTrue(!attackerB.tryFree(50 ether));
        // including the attacker's other address, so mkr is lost in this attack
        // (note that the attacker may use their burn address to vote for 5 candidates, effectively allowing them to remove 5 - 20 approvals for each mkr they lock)
    }

    // if two people have been exploited and can no longer free their mkr,
    // it only takes one person depositing mkr to make both other voters' mkr available again
    // in the best case, b/c the slate size if 5, one person can allow 4 people to free their mkr
    function testFail_one_mkr_in_two_mkr_out() public {
        testFail_exploit_A();
        // both innocent voters have deposits
        assertEq(voteQuorum.deposits(address(innocentVoterA)), 50 ether);
        assertEq(voteQuorum.deposits(address(innocentVoterB)), 50 ether);
        // but neither of the candidates they are voting for have approvals
        // (we assume both voters are voting for a slate containing exactly one proposal and that they are not voting for the same proposal)
        assertEq(voteQuorum.approvals(voteQuorum.slates(voteQuorum.votes(address(innocentVoterA)), 0)), 0 ether);
        assertEq(voteQuorum.approvals(voteQuorum.slates(voteQuorum.votes(address(innocentVoterB)), 0)), 0 ether);
        // so neither voter can withdraw mkr despite their deposit balance
        assertTrue(!innocentVoterA.tryFree(50 ether));
        assertTrue(!innocentVoterB.tryFree(50 ether));

        // but an altruistic person may add some approvals to both of the other voter's candidates
        address[] memory candidatesAB = new address[](2);
        candidatesAB[0] = voteQuorum.slates(voteQuorum.votes(address(innocentVoterA)), 0);
        candidatesAB[1] = voteQuorum.slates(voteQuorum.votes(address(innocentVoterB)), 0);
        altruist.lock(50 ether);
        altruist.vote(candidatesAB);

        // now both candidates have some approvals
        assertEq(voteQuorum.approvals(voteQuorum.slates(voteQuorum.votes(address(innocentVoterA)), 0)), 50 ether);
        assertEq(voteQuorum.approvals(voteQuorum.slates(voteQuorum.votes(address(innocentVoterB)), 0)), 50 ether);
        // so both of the innocent voters can free their mkr again
        assertTrue(innocentVoterA.tryFree(50 ether));
        assertTrue(innocentVoterB.tryFree(50 ether));
        // however the altruist can not
        assertTrue(!altruist.tryFree(50 ether));

        // the conditions for this to work are:
    }

    // these tests illustrate 3 different ways to use the slate camping exploit
    // there are variations within each method -- this becomes especially clear when you consier slates can contain between 1 and 5 addresses
    // in addition, there are possibly more yet undiscovered but similar ways to cause trouble
}
