pragma solidity 0.6.7;

import "ds-test/test.sol";
import {DSThing} from 'ds-thing/thing.sol';
import "ds-token/token.sol";

import "../VoteQuorum.sol";

contract VoteQuorumUser {
    VoteQuorum voteQuorum;

    constructor(VoteQuorum voteQuorum_) public { voteQuorum = voteQuorum_; }
    function approve(DSToken token, address recipient, uint amount) public returns (bool)  {
        return token.approve(recipient, amount);
    }

    function groupCandidates(address[] memory guys) public returns (bytes32) { return voteQuorum.groupCandidates(guys); }
    function vote(address[] memory guys) public returns (bytes32) { return voteQuorum.vote(guys); }
    function vote(bytes32 id) public { voteQuorum.vote(id); }
    function electCandidate(address candidate) public { voteQuorum.electCandidate(candidate); }
    function addVotingWeight(uint amt) public { voteQuorum.addVotingWeight(amt); }
    function removeVotingWeight(uint amt) public { voteQuorum.removeVotingWeight(amt); }

    function tryRemoveVotingWeight(uint amt) public returns (bool ok) {
        string memory sig = "removeVotingWeight(uint256)";
        (ok,) = address(voteQuorum).call(abi.encodeWithSignature(sig, amt));
    }
}

contract VoteQuorumTest is DSThing, DSTest {
    address constant candidateA = address(0x1);
    address constant candidateB = address(0x2);
    address constant candidateC = address(0x3);

    VoteQuorum voteQuorum;
    DSToken prot;
    DSToken iou;

    VoteQuorumUser innocentVoterA;
    VoteQuorumUser innocentVoterB;
    VoteQuorumUser altruist;
    VoteQuorumUser attackerA;
    VoteQuorumUser attackerB;

    function setUp() public {
        prot = new DSToken("PROT", "PROT");

        VoteQuorumFactory fab = new VoteQuorumFactory();
        voteQuorum = fab.newVoteQuorum(prot, 3);
        iou = voteQuorum.IOU();

        innocentVoterA = new VoteQuorumUser(voteQuorum);
        innocentVoterB = new VoteQuorumUser(voteQuorum);

        altruist = new VoteQuorumUser(voteQuorum);

        attackerA = new VoteQuorumUser(voteQuorum);
        attackerB = new VoteQuorumUser(voteQuorum);

        prot.mint(address(innocentVoterA), 50 ether);
        prot.mint(address(innocentVoterB), 50 ether);
        prot.mint(address(altruist), 50 ether);
        prot.mint(address(attackerA), 50 ether);
        prot.mint(address(attackerB), 50 ether);
    }

    function approveAll() public {
        innocentVoterA.approve(prot, address(voteQuorum), 50 ether);
        innocentVoterB.approve(prot, address(voteQuorum), 50 ether);
        altruist.approve(prot, address(voteQuorum), 50 ether);
        attackerA.approve(prot, address(voteQuorum), 50 ether);
        attackerB.approve(prot, address(voteQuorum), 50 ether);
        innocentVoterA.approve(iou, address(voteQuorum), 50 ether);
        innocentVoterB.approve(iou, address(voteQuorum), 50 ether);
        altruist.approve(iou, address(voteQuorum), 50 ether);
        attackerA.approve(iou, address(voteQuorum), 50 ether);
        attackerB.approve(iou, address(voteQuorum), 50 ether);
    }

    function test_token_balance_sanity_check() public {
        assertEq(prot.balanceOf(address(innocentVoterA)), 50 ether);
        assertEq(prot.balanceOf(address(innocentVoterB)), 50 ether);
        assertEq(prot.balanceOf(address(attackerA)), 50 ether);
    }

    // variants of the ballot camping exploit

    function testFail_exploit_A() public {
        approveAll();
        innocentVoterA.addVotingWeight(50 ether);
        innocentVoterB.addVotingWeight(50 ether);
        attackerA.addVotingWeight(50 ether);

        // everybody starts with 50 protocol tokens
        assertEq(voteQuorum.deposits(address(innocentVoterA)), 50 ether);
        assertEq(voteQuorum.deposits(address(innocentVoterB)), 50 ether);
        assertEq(voteQuorum.deposits(address(attackerA)), 50 ether);

        // some person votes for cadidate A
        address[] memory candidatesA = new address[](1);
        candidatesA[0] = candidateA;
        innocentVoterA.vote(candidatesA);
        assertEq(voteQuorum.approvals(address(candidateA)), 50 ether);
        assertEq(voteQuorum.approvals(address(candidateB)), 0 ether);

        // some person votes for cadidate B
        address[] memory candidatesB = new address[](1);
        candidatesB[0] = candidateB;
        innocentVoterB.vote(candidatesB);
        assertEq(voteQuorum.approvals(address(candidateA)), 50 ether);
        assertEq(voteQuorum.approvals(address(candidateB)), 50 ether);

        // the attacker votes for an uneteched ballot that contains both a and b
        address[] memory candidatesAB = new address[](2);
        candidatesAB[0] = candidateA;
        candidatesAB[1] = candidateB;
        bytes32 ballot = keccak256(abi.encodePacked(candidatesAB));
        attackerA.vote(ballot);
        // this does not add approvals to either candidate
        assertEq(voteQuorum.approvals(address(candidateA)), 50 ether);
        assertEq(voteQuorum.approvals(address(candidateB)), 50 ether);

        // the attacker can now group candidates the ballot [a, b] and remove their protocol tokens
        attackerA.groupCandidates(candidatesAB);
        assertTrue(attackerA.tryRemoveVotingWeight(50 ether));
        assertEq(prot.balanceOf(address(attackerA)), 50 ether);
        // approvals have been removed from both proposals
        assertEq(voteQuorum.approvals(address(candidateA)), 0 ether);
        assertEq(voteQuorum.approvals(address(candidateB)), 0 ether);
        // neither innocent voter can remove their protocol tokens
        assertTrue(!innocentVoterA.tryRemoveVotingWeight(50 ether));
        assertTrue(!innocentVoterB.tryRemoveVotingWeight(50 ether));
    }

    // "single candidate ballot camping"
    function testFail_exploit_B() public {
        approveAll();
        innocentVoterA.addVotingWeight(50 ether);
        innocentVoterB.addVotingWeight(50 ether);
        attackerA.addVotingWeight(50 ether);

        // the attacker gets word of the address of the latest maker spell
        address[] memory candidatesA = new address[](1);
        candidatesA[0] = candidateA;
        bytes32 ballot = keccak256(abi.encodePacked(candidatesA));
        // so they squat on the ballot containing it
        // note: this only works if the ballot containing just that candidate has not yet been grouped
        attackerA.vote(ballot);
        // this does not add approvals to candidate a
        assertEq(voteQuorum.approvals(address(candidateA)), 0 ether);

        // now somebody votes for candidate a
        // (this groups the candidates from ballot [a])
        innocentVoterA.vote(candidatesA);
        // this adds 50 approvals to candidate a
        assertEq(voteQuorum.approvals(address(candidateA)), 50 ether);

        // the attacker can withdraw their protocol tokens
        assertTrue(attackerA.tryRemoveVotingWeight(50 ether));
        assertEq(prot.balanceOf(address(attackerA)), 50 ether);
        // this removes 50 approvals from candidate a
        assertEq(voteQuorum.approvals(address(candidateA)), 0 ether);

        // the innocent voter can no longer remove their protocol tokens
        assertTrue(!innocentVoterA.tryRemoveVotingWeight(50 ether));
    }

    // as a last ditch effort, an attacker can _always_ remove approvals and perma-lock protocol tokens if they are willing to spend protocol tokens first.
    // this may be necessary if every ballot combination of candidates with some approval amount has already been grouped
    // and the attacker doesn't want to play the waiting game required for variant b
    function testFail_exploit_C() public {
        approveAll();
        innocentVoterA.addVotingWeight(50 ether);
        innocentVoterB.addVotingWeight(50 ether);

        // some voters are voting for candidates a and b
        address[] memory candidatesA = new address[](1);
        candidatesA[0] = candidateA;
        innocentVoterA.vote(candidatesA);
        address[] memory candidatesB = new address[](1);
        candidatesB[0] = candidateB;
        innocentVoterB.vote(candidatesB);
        assertEq(voteQuorum.approvals(address(candidateA)), 50 ether);
        assertEq(voteQuorum.approvals(address(candidateB)), 50 ether);

        // group the last possible unique ballot given the two candidates
        address[] memory candidatesAB = new address[](2);
        candidatesAB[0] = candidateA;
        candidatesAB[1] = candidateB;
        innocentVoterA.groupCandidates(candidatesAB);
        // the attacker can no longer perform a "variant a" style attack

        // however, the attacker can always find a ballot with ungrouped candidates by adding an arbitrary address
        attackerA.addVotingWeight(50 ether);
        address[] memory candidatesABC = new address[](3);
        candidatesABC[0] = candidateA;
        candidatesABC[1] = candidateB;
        candidatesABC[2] = candidateC;
        bytes32 ballot = keccak256(abi.encodePacked(candidatesABC));
        attackerA.vote(ballot);
        // this does not add approvals to any candidate
        assertEq(voteQuorum.approvals(address(candidateA)), 50 ether);
        assertEq(voteQuorum.approvals(address(candidateB)), 50 ether);
        assertEq(voteQuorum.approvals(address(candidateC)), 0 ether);

        // since candidate c has no approvals, the attacker can also not yet perform the attack
        attackerA.groupCandidates(candidatesABC);
        assertTrue(!attackerA.tryRemoveVotingWeight(50 ether));
        // but they can use a second address to add approvals to the new address
        attackerB.addVotingWeight(50 ether);
        address[] memory candidatesC = new address[](1);
        candidatesC[0] = candidateC;
        attackerB.vote(candidatesC);
        assertEq(voteQuorum.approvals(address(candidateA)), 50 ether);
        assertEq(voteQuorum.approvals(address(candidateB)), 50 ether);
        assertEq(voteQuorum.approvals(address(candidateC)), 50 ether);

        // now the attacker may remove protocol tokens, removing approvals from all candidates
        assertTrue(attackerA.tryRemoveVotingWeight(50 ether));
        assertEq(voteQuorum.approvals(address(candidateA)), 0 ether);
        assertEq(voteQuorum.approvals(address(candidateB)), 0 ether);
        assertEq(voteQuorum.approvals(address(candidateC)), 0 ether);

        // nobody else can remove their protocol tokens
        assertTrue(!innocentVoterA.tryRemoveVotingWeight(50 ether));
        assertTrue(!innocentVoterB.tryRemoveVotingWeight(50 ether));
        assertTrue(!attackerB.tryRemoveVotingWeight(50 ether));
        // including the attacker's other address, so protocol tokens is lost in this attack
        // (note that the attacker may use their burn address to vote for 5 candidates, effectively allowing them to remove 5 - 20 approvals for each protocol tokens they lock)
    }

    // if two people have been exploited and can no longer remove their protocol tokens,
    // it only takes one person depositing protocol tokens to make both other voters' protocol tokens available again
    // in the best case, b/c the ballot size if 5, one person can allow 4 people to remove their protocol tokens
    function testFail_one_protocol_token_in_two_tokens_out() public {
        testFail_exploit_A();
        // both innocent voters have deposits
        assertEq(voteQuorum.deposits(address(innocentVoterA)), 50 ether);
        assertEq(voteQuorum.deposits(address(innocentVoterB)), 50 ether);
        // but neither of the candidates they are voting for have approvals
        // (we assume both voters are voting for a ballot containing exactly one proposal and that they are not voting for the same proposal)
        assertEq(voteQuorum.approvals(voteQuorum.ballots(voteQuorum.votes(address(innocentVoterA)), 0)), 0 ether);
        assertEq(voteQuorum.approvals(voteQuorum.ballots(voteQuorum.votes(address(innocentVoterB)), 0)), 0 ether);
        // so neither voter can withdraw protocol tokens despite their deposit balance
        assertTrue(!innocentVoterA.tryRemoveVotingWeight(50 ether));
        assertTrue(!innocentVoterB.tryRemoveVotingWeight(50 ether));

        // but an altruistic person may add some approvals to both of the other voter's candidates
        address[] memory candidatesAB = new address[](2);
        candidatesAB[0] = voteQuorum.ballots(voteQuorum.votes(address(innocentVoterA)), 0);
        candidatesAB[1] = voteQuorum.ballots(voteQuorum.votes(address(innocentVoterB)), 0);
        altruist.addVotingWeight(50 ether);
        altruist.vote(candidatesAB);

        // now both candidates have some approvals
        assertEq(voteQuorum.approvals(voteQuorum.ballots(voteQuorum.votes(address(innocentVoterA)), 0)), 50 ether);
        assertEq(voteQuorum.approvals(voteQuorum.ballots(voteQuorum.votes(address(innocentVoterB)), 0)), 50 ether);
        // so both of the innocent voters can remove their protocol tokens again
        assertTrue(innocentVoterA.tryRemoveVotingWeight(50 ether));
        assertTrue(innocentVoterB.tryRemoveVotingWeight(50 ether));
        // however the altruist can not
        assertTrue(!altruist.tryRemoveVotingWeight(50 ether));

        // the conditions for this to work are:
    }

    // these tests illustrate 3 different ways to use the ballot camping exploit
    // there are variations within each method -- this becomes especially clear when you consier ballots can contain between 1 and 5 addresses
    // in addition, there are possibly more yet undiscovered but similar ways to cause trouble
}
